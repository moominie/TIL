# 모두를 위한 컴퓨터 과학(CS50 2019) - David J. Malan

- CS50 : 하버드 대학교의 컴퓨터과학 입문 강좌 



##### <학습 목표>

1. 컴퓨터 과학의 기초 개념을 이해할 수 있다.
2. C를 이용하여 배열, 자료구조, 알고리즘을 실습해볼 수 있다.
3. 프로그래밍에 필요한 컴퓨팅 사고를 기를 수 있다.



## 3. Array(1)



### 1) 컴파일링

##### <학습 목표>

컴파일링의 네 단계를 설명할 수 있다.



##### <키워드>

C코드 복습

```c
#include <stdio.h>

int main(void)
{
  printf("hello, world\n");
}
```

- main() 함수 : 프로그램의 시작점  
- printf() 함수 : 출력을 담당하는 함수, printf 함수 사용을 위해서는 stdio.h 라이브러리가 필요함 
- stdio.h : C 언어로 작성되어 파일명이 .h로 끝나는 헤더 파일, 이 파일에 printf 함수의 프로토타입이 있어서 Clang 컴파일러가 프로그램을 컴파일할 때 printf가 무엇인지 알려주는 역할을 함  



컴파일 명령어

1. `clang -0 hello hello.c -lcs50`

​		cs50 라이브러리를 사용한 프로그램을 컴파일 할 때에는 clang에 -lcs50 프로그램을 추가해야 하는데, 이는 clang에게 cs50 라이브러리에 있는 모든 0과 1들을 여기에 연결하라는 의미  

2. `make hello `

​		위의 모든 컴파일 과정을 자동으로 처리할 수 있음  



컴파일의 네 가지 단계

1. 전처리
2. 컴파일링
3. 어셈블링
4. 링킹



###### 전처리(precompile)

컴파일의 첫 번째 단계, 전처리기에 의해 수행됨  

#으로 시작되는 C 소스 코드는 전처리기에 실질적인 컴파일이 수행되기 전에 무언가를 실행하라고 알려줌  

(예시) `# include <stdio.h>`

: 전처리기는 C 소스 코드 형태의 새로운 파일을 생성하며 stdio.h 파일의 내용이 #include 부분에 포함됨  



###### 컴파일(compile)

전처리기가 전처리한 소스 코드를 생성하고 나면, 컴파일러가 이 C 코드를 어셈블리어라는 저수준 프로그래밍 언어로 컴파일함  

C 코드를 어셈블리 코드로 변환시켜줌으로써 컴파일러는 컴퓨터가 이해할 수 있는 언어와 최대한 가까운 프로그램으로 만들어 줌  



###### 어셈블(assemble)

어셈블리 코드를 오브젝트 코드로 변환시키는 것으로 어셈블러에 의해 수행됨  

컴퓨터의 중앙처리장치가 프로그램을 어떻게 수행해야 하는지 알 수 있는 명령어 형태인 연속된 0과 1들로 바꿔주는 작업  



###### 링크(link)

만약 프로그램이 math.h나 cs50.h와 같은 라이브러리를 포함해 여러 개의 파일로 이루어져 있어 하나의 오브젝트 파일로 합쳐져야 한다면 링크 단계가 필요함  

링커에 의해 수행되며, 여러 개의 다른 오브젝트 코드 파일을 실행 가능한 하나의 오브젝트 코드 파일로 합쳐 줌  



##### <생각해보기>

만약 컴파일링 과정을 거치지 않기 위해 바로 머신코드로 우리가 원하는 프로그램을 작성하려고 한다면 어떤 문제가 있을까?  

0과 1로만 이루어진 코드 작성으로 가독성, 정확도, 효율성이 떨어질 것이다. 







### 2) 디버깅

##### <학습 목표>

디버깅하는 여러 방법을 설명할 수 있다.  



##### <키워드>

###### 버그(bug)

코드에 들어있는 오류  



###### 디버깅(debugging)

코드에 있는 버그를 식별하고 고치는 과정  

디버거라는 프로그램을 사용하여 디버깅을 함  



###### 중지점(break point)

디버거는 프로그램을 특정 행에서 멈출 수 있게 해주기 때문에 프로그래머는 멈춰진 그 지점에서 버그를 찾아볼 수 있음  

이때 프로그램이 멈추는 특정 지점을 중지점(break point)라고 함  



###### help50

```c
int main(void)
{
    printf("hello, world\n");
}
```

```c
$ make debug0
```

위 코드를 make 명령어로 컴파일하면 `debug0.c:3:5: error: implicitly declaring library function 'printf' with type 'int (const char *, ...)'` 에러가 발생함  

이러한 에러 메세지를 이해하기 힘들 때 help50 프로그램을 사용할 수 있음

```c
$ help50 make debug0
```

위와 같이 help50을 붙여서 컴파일을 실행하면 `Did you forget to #include <stdio.h> (in which printf is declared) atop your file?` 이라고 오류를 해석해줌  



###### printf

\# 10개를 출력하기 위한 코드 작성

```c
#include <stdio.h>

int main(void)
{
    for(int i=0; i<=10; i++)
    {
        printf("#\n");
    }
}
```

위 코드를 컴파일하고 실행하면 에러는 발생하지 않지만 #이 11개가 출력됨  

이때 printf로 직접 의심이 가는 변수를 출력해서 확인할 수 있음 

```c
#include <stdio.h>

int main(void)
{
    for(int i=0; i<=10; i++)
    {
        printf("i is now %i ", i);
        printf("#\n");
    }
}
```

 그 결과 i가 0에서 시작하기 때문에 for 루프의 조건을 `i<10` 으로 수정해야 한다는 것을 알 수 있음  



###### debug50

CS50 IDE(Integrated Development Environment, 통합개발환경) 을 사용하면 debug50이라는 프로그램을 사용할 수 있음   

소스 코드에 직접 breakpoint를 지정하고 소스 파일을 컴파일한 후에 `$ debug50 파일명` 으로 실행하면 오른쪽 패널을 통해 변수의 값을 확인하거나 breakpoint부터 한 줄씩 코드를 실행해볼 수 있음  

디버깅 종료를 위해서는 `Ctrl + c` 를 누름 



###### GDB

자주 쓰이는 디버거  



##### <생각해보기>

디버깅을 도와주는 프로그램은 어떤 경우에 더 큰 도움이 될까? 만약 이런 프로그램의 도움 없이 직접 디버깅을 해야 한다면 어떻게 코드를 작성하는 것이 좋을까?  



코드가 복잡할 때, printf()로 코드 실행 상황을 한 줄 씩 확인할 수 있도록 코드를 작성한다.







### 3) 코드의 디자인

##### <학습 목표>

코드의 정확성과 디자인을 관리하는 방법을 설명할 수 있다.  



##### <키워드>

###### check50

cs50 강의를 듣고 과제를 잘 작성했는지 확인할 수 있는 프로그램  



###### style50

코드가 심미적으로 잘 작성되어 있는지 검사할 수 있는 프로그램  



###### 고무 오리(rubber duck)

코드에 포함된 오류를 해결하는 것이 잘 안 될 때에는 먼저 한숨 돌리고 직접 곰곰히 생각하는 것이 좋음  

한 가지 유명한 방법은 고무 오리와 같이 무언가 대상이 되는 물체를 앞에 두고, 내가 작성한 코드를 한 줄 한 줄 말로 설명해주는 과정을 거쳐볼 수 있음   

이를 통해 미처 놓치고 있었던 논리적 오류를 찾아낼 수 있음  



##### <생각해보기>

만약 여러 사람들이 함께 참여하는 프로젝트에서, 각자가 작성하는 코드 스타일이 서로 다르다면 어떤 비효율적인 일이 발생할까?  



통일성, 가독성이 떨어지고, 디버깅이 어려워질 수 있다.  

결과적으로 업무 효율이 떨어질 것이다.  
